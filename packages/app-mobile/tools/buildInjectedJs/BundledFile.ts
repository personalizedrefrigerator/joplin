// React Native WebView cannot load external JS files, however it can load
// arbitrary JS via the injectedJavaScript property. So we use this to load external
// files: First here we convert the JS file to a plain string, and that string
// is then loaded by eg. the Mermaid plugin, and finally injected in the WebView.

import { dirname, extname, basename } from 'path';

import * as esbuild from 'esbuild';
import copyJs from './copyJs';
import { writeFile } from 'fs-extra';

export default class BundledFile {
	private readonly bundleOutputPath: string;
	private readonly bundleBaseName: string;
	private readonly rootFileDirectory: string;

	public constructor(
		public readonly bundleName: string,
		private readonly sourceFilePath: string,
	) {
		this.rootFileDirectory = dirname(sourceFilePath);
		this.bundleBaseName = basename(sourceFilePath, extname(sourceFilePath));
		this.bundleOutputPath = `${this.rootFileDirectory}/${this.bundleBaseName}.bundle.js`;
	}

	private makeBuildContext(mode: 'production' | 'development') {
		return esbuild.context({
			entryPoints: [this.sourceFilePath],
			outfile: this.bundleOutputPath,
			minify: mode === 'production',
			bundle: true,
			sourcemap: true,
			format: 'iife',
			globalName: this.bundleName,
			metafile: false,

			// es5: Have Webpack's generated code target ES5. This doesn't apply to code not
			//      generated by Webpack.
			target: ['chrome58', 'safari14'],

			plugins: [
				{
					name: 'joplin--node-polyfills',
					setup: build => {
						build.onResolve({ filter: /^(path|events)$/ }, args => {
							let path = args.path;
							if (args.path === 'path') {
								path = require.resolve('path-browserify');
							} else if (args.path === 'events') {
								path = require.resolve('events/');
							}

							return { path };
						});
					},
				},
				{
					name: 'joplin--copy-final',
					setup: build => {
						build.onEnd(async (result) => {
							if (result.outputFiles?.length === 1) {
								await this.copyToImportableFile();
							} else {
								console.warn('Copying skipped. Build produced', result.outputFiles?.length, 'output file(s).');
							}
						});
					},
				},
			],
		});
	}

	// Creates a file that can be imported by React native. This file contains the
	// bundled JS as a string.
	private async copyToImportableFile() {
		await copyJs(`${this.bundleName}.bundle`, this.bundleOutputPath);
	}

	// Create a minified JS file in the same directory as `this.sourceFilePath` with
	// the same name.
	public async build() {
		console.info(`Building bundle: ${this.bundleName}...`);
		const compiler = await this.makeBuildContext('production');
		const result = await compiler.rebuild();
		await compiler.dispose();

		if (result?.metafile) {
			await writeFile(`${this.bundleOutputPath}.meta.json`, JSON.stringify(result.metafile, undefined, '\t'));
		}
	}

	public async startWatching() {
		console.info(`Watching bundle: ${this.bundleName}...`);
		const compiler = await this.makeBuildContext('development');
		await compiler.watch();
	}
}
